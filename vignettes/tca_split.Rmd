---
title: "tca_split"
output: 
  rmarkdown::pdf_document:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{tca_split}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Synopsis
* This vignette shows the behavior of `tca()` and `tca_split()`. 
First, we show that the modded version of `TCA::tca()` produces the same result 
using Hannum et. al. 2013 Chr22 data as the fir by the 1.2.1 version.
* For `tca_split()`, if tau is estimated from the data, either set 
`vars.mle = TRUE` or the chunk size must be big enough.
* Used appropriately, `tca_split()` and `tca()` returns highly correlated 
results `(cor > 0.99)`.

```{r setup}
library(TCA)
library(furrr)
```

```{r, include = FALSE}
# Helper to compare correlation
compare_fit_corr <- function(fit1, fit2, digits = 4) {
  estimates <-
    c(
      "mus_hat", "sigmas_hat", "deltas_hat", "gammas_hat", "deltas_hat_pvals",
      "gammas_hat_pvals", "gammas_hat_pvals.joint"
    )

  align_cor <- function(mat1, mat2) {
    stopifnot(is.matrix(mat1), is.matrix(mat2))
    stopifnot(all(row.names(mat1) %in% row.names(mat2)))
    mat3 <- mat2[row.names(mat1), , drop = FALSE] # Aligning mat2 with mat1
    return(sapply(seq_len(ncol(mat3)), \(x) {
      round(cor(mat1[, x], mat3[, x]), digits)
    }))
  }

  return(
    purrr::set_names(
      lapply(estimates, \(x) {
        align_cor(fit1[[x]], fit2[[x]])
      }),
      estimates
    )
  )
}
```

# Replicating Hannum et. al. 2013 fit
```{r, eval = F}
load("./vignettes/hannum.chr22.RData")
```

```{r, include = F}
load("hannum.chr22.RData")
```

* First we fit the data following `tca-vignette.Rmd` using `tca()` version 1.2.1.  
```{r, eval = F}
set.seed(1234)
tca_fit_fns <- purrr::partial(
  tca,
  X = hannum$X,
  W = hannum$W,
  C1 = hannum$cov[, c("gender", "age")],
  C2 = hannum$cov[, 3:ncol(hannum$cov)]
)

tca.mdl.hannum <- tca_fit_fns()
tca.mdl.hannum.mle <- tca_fit_fns(vars.mle = TRUE)
```

```{r, eval = F, include = F}
saveRDS(
  list(tca_1_2_1 = tca.mdl.hannum, tca_1_2_1.mle = tca.mdl.hannum.mle),
  "./vignettes/hannum_1_2_1.rds"
)
```

* Then we install the modded version and re-fit the models.  
```{r, eval = F}
detach("package:TCA", unload = TRUE)
remove.packages("TCA")
devtools::install_github("hhp94/TCA@profiling")
```

```{r, eval = F}
library(TCA) # Modded fit

set.seed(1234)
tca.mdl.hannum.mod <- tca_fit_fns()
tca.mdl.hannum.mle.mod <- tca_fit_fns(vars.mle = TRUE)
```

```{r, eval = F, include = F}
saveRDS(
  list(tca_modded = tca.mdl.hannum.mod, tca_modded.mle = tca.mdl.hannum.mle.mod),
  "./vignettes/hannum_modded.rds"
)
```

```{r, include = F}
fit_1_2_1 <- readRDS("hannum_1_2_1.rds")
fit_modded <- readRDS("hannum_modded.rds")

tca.mdl.hannum <- fit_1_2_1$tca_1_2_1
tca.mdl.hannum.mle <- fit_1_2_1$tca_1_2_1.mle

tca.mdl.hannum.mod <- fit_modded$tca_modded
tca.mdl.hannum.mle.mod <- fit_modded$tca_modded.mle
```

* `compare_fit_corr` compares the correlation between the estimates. We see that 
the mod did not affect the fit results.  
```{r}
compare_fit_corr(tca.mdl.hannum, tca.mdl.hannum.mod)
compare_fit_corr(tca.mdl.hannum.mle, tca.mdl.hannum.mle.mod)
```

# tca_split()
* First we run a sequential `TCA::tca()` and one with `vars.mle = TRUE`  
```{r}
set.seed(1234)
n_features <- 150
data <- test_data(40, n_features, 3, 2, 2, 0.03, verbose = FALSE)
```

```{r, eval = F}
tca_seq <- tca(
  X = data$X, W = data$W, C1 = data$C1, C2 = data$C2,
  log_file = NULL, verbose = FALSE
)

tca_seq_mle <- tca(
  X = data$X, W = data$W, C1 = data$C1, C2 = data$C2,
  log_file = NULL, verbose = FALSE, vars.mle = TRUE,
  max_iters = 20
) 
```

* Then we do the same for `tca_split()` under the following scenarios:
  1. There are as many chunks as there are parallel workers, in this case 4.
  2. Extreme case where there are as many chunks as there are features, in 
  this case `r n_features`.
  3. Same as 2., but `vars.mle = TRUE`
  
```{r}
split_X_4 <- split_input(data$X, 4, shuffle = TRUE) # Split X into 4 chunks
split_X <- split_input(data$X, n_features) # Split X into as many chunks as feat
```

* Fit with `TCA::tca_split()`  
```{r, eval = FALSE}
# Not actually ran to save time
plan(multisession, workers = 4)
# There are as many chunks as there are parallel workers
tca_par_4 <- tca_split(
  split_X_4, W = data$W, C1 = data$C1, C2 = data$C2,
  log_file_prefix = NULL, verbose = FALSE
)
# There are as many chunks as there are features
tca_par <- tca_split(
  split_X, W = data$W, C1 = data$C1, C2 = data$C2,
  log_file_prefix = NULL, verbose = FALSE
)
# There are as many chunks as there are features, `vars.mle = TRUE`
tca_par_mle <- tca_split(
  split_X, W = data$W, C1 = data$C1, C2 = data$C2,
  log_file_prefix = NULL, verbose = FALSE,
  vars.mle = TRUE, max_iters = 20
)
plan(sequential)
```

```{r, eval = FALSE, include = FALSE}
saveRDS(
  list(
    tca_seq = tca_seq,
    tca_seq_mle = tca_seq_mle,
    tca_par_4 = tca_par_4,
    tca_par = tca_par,
    tca_par_mle = tca_par_mle
  ),
  "./vignettes/tca_split.rds"
)
```

```{r, include = FALSE}
raw <- readRDS("tca_split.rds")
for (i in names(raw))  {
  assign(i, raw[[i]])
}
rm(raw)
```

## Results  
* We see that for 4 chunks, the `tca_split()` and `tca()` fits are very correlated.  
```{r}
compare_fit_corr(tca_seq, tca_par_4) # tca_seq vs tca_split with 4 Chunks of X
```

* However, for as many chunks as there are features, the correlation expectedly 
drops significantly. Especially for `sigmas_hat` and `gammas_hat_pvals`.  
```{r}
# tca_seq vs tca_split with as many chunks of X as there is features
compare_fit_corr(tca_seq, tca_par)
```

* `tau_hat` are close enough and is close to true `tau`  
```{r}
unname(tca_seq$tau_hat)
mean(tca_par_4$tau_hat)
mean(tca_par$tau_hat)
```

* For  as many chunks as there are features `vars.mle = TRUE`, the correlation 
stays high.  
```{r}
# tca_seq vs tca_split with as many chunks of X as there is features, vars.mle = TRUE
compare_fit_corr(tca_seq_mle, tca_par_mle)
```

